/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

const path = require('path')
const fs = require('fs')
const webpack = require('webpack')
const {
  readJson,
  colorconsole,
  KnownError,
  getProjectDslName,
  getDefaultServerHost
} = require('@hap-toolkit/shared-utils')
const globalConfig = require('@hap-toolkit/shared-utils/config')

const {
  compileOptionsMeta,
  compileOptionsObject,
  initCompileOptionsObject
} = require('@hap-toolkit/shared-utils/compilation-config')
const { name } = require('@hap-toolkit/packager/lib/common/info')

const ManifestWatchPlugin = require('../lib/plugins/manifest-watch-plugin')
const { resolveEntries } = require('../lib/utils')
const getDevtool = require('./get-devtool')
const {
  getConfigPath,
  validateProject,
  cleanup,
  checkBuiltinModules,
  setAdaptForV8Version
} = require('./helpers')

const pathMap = {
  packager: require.resolve('@hap-toolkit/packager/lib/webpack.post.js'),
  xvm: require.resolve(`@hap-toolkit/dsl-xvm/lib/webpack.post.js`),
  vue: require.resolve(`@hap-toolkit/dsl-vue/lib/webpack.post.js`)
}

// 主包保留名
const MAIN_PKG_NAME = compileOptionsMeta.MAIN_PKG_NAME
// 能使用rpks能力的调试器最低版本
const RPKS_SUPPORT_VERSION_FROM = 1040
// 能使用抽取公共js功能的调试器最低版本
const SPLIT_CHUNKS_SUPPORT_VERSION_FROM = 1080

/**
 * 动态生成 webpack 配置项
 *
 * @param {Object} launchOptions - 命令行参数对象
 * @param {String} [launchOptions.cwd] - 工作目录
 * @param {String} [launchOptions.devtool=undefined] - devtool(sourcemap)配置
 * @param {boolean} [launchOptions.debug=false] - 是否开启调试
 * @param {boolean} [launchOptions.stats=false] - 是否开启分析
 * @param {boolean} [launchOptions.disableSubpackages=false] - 是否禁止分包
 * @param {boolean} [launchOptions.optimizeCssAttr=false] - 优化 css 属性
 * @param {boolean} [launchOptions.optimizeDescMeta=false] - 优化 css 描述数据
 * @param {boolean} [launchOptions.optimizeTemplateAttr=false] - 优化模板属性
 * @param {boolean} [launchOptions.optimizeStyleAppLevel=false] - 优化 app 样式等级
 * @param {boolean} [launchOptions.optimizeStylePageLevel=false] - 优化 app 样式等级
 * @param {boolean} [launchOptions.splitChunksMode=undefined] - 抽取公共JS
 * @param {production|development} mode - webpack mode
 * @returns {WebpackConfiguration}
 */
module.exports = function genWebpackConf(launchOptions, mode) {
  // 项目目录
  if (launchOptions.cwd) {
    globalConfig.projectPath = launchOptions.cwd
  }
  const cwd = globalConfig.projectPath

  const hapConfigPath = getConfigPath(cwd)
  // 用于接受quickapp.config.js 或者 hap.config.js中的配置
  let quickappConfig
  // 接受命令行
  let cli = {}
  if (hapConfigPath) {
    try {
      quickappConfig = require(hapConfigPath)
      if (typeof quickappConfig.cli === 'object') {
        cli = quickappConfig.cli
        launchOptions = Object.assign({}, cli, launchOptions)
      }
    } catch (err) {
      colorconsole.error(`加载webpack配置文件[${hapConfigPath}]出错：${err.message}`)
    }
  }

  // 源代码目录
  const SRC_DIR = path.resolve(cwd, globalConfig.sourceRoot)
  // 签名文件目录
  const SIGN_FOLDER = globalConfig.signRoot
  // 编译文件的目录
  const BUILD_DIR = path.resolve(cwd, globalConfig.outputPath)
  // 最终发布目录
  const DIST_DIR = path.resolve(cwd, globalConfig.releasePath)
  // 打包配置文件
  const manifestFile = path.resolve(SRC_DIR, 'manifest.json')

  // 合并launchOptions到全局
  initCompileOptionsObject(launchOptions)

  // 校验项目工程
  validateProject(manifestFile)

  // 清理 BUILD_DIR DIST_DIR
  cleanup(BUILD_DIR, DIST_DIR)

  let manifest
  try {
    manifest = readJson(manifestFile)
  } catch (e) {
    throw new KnownError('manifest.json 解析失败！')
  }

  validateManifest(manifest, compileOptionsObject)

  // 设置合适的v8版本
  setAdaptForV8Version(compileOptionsObject.disableScriptV8V65, manifest, cwd)

  // 页面文件
  const entries = resolveEntries(manifest, SRC_DIR, cwd)

  // 环境变量
  const env = {
    // 平台：native
    NODE_PLATFORM: process.env.NODE_PLATFORM,
    // 阶段: dev|test|release
    NODE_PHASE: process.env.NODE_PHASE
  }
  colorconsole.info(`配置环境：${JSON.stringify(env)}`)

  const webpackConf = {
    context: cwd,
    mode,
    entry: entries,
    output: {
      path: BUILD_DIR,
      filename: '[name].js'
    },
    module: {
      rules: []
    },
    externals: [checkBuiltinModules],
    plugins: [
      // 定义环境变量
      new webpack.DefinePlugin({
        // 平台：na
        ENV_PLATFORM: JSON.stringify(env.NODE_PLATFORM),
        // 阶段: dev|test|release
        ENV_PHASE: JSON.stringify(env.NODE_PHASE),
        ENV_PHASE_DV: env.NODE_PHASE === 'dev',
        ENV_PHASE_QA: env.NODE_PHASE === 'test',
        ENV_PHASE_OL: env.NODE_PHASE === 'prod',
        // 服务器地址
        QUICKAPP_SERVER_HOST: JSON.stringify(getDefaultServerHost()),
        QUICKAPP_TOOLKIT_VERSION: JSON.stringify(require('../package.json').version)
      }),
      // 编译耗时
      function BuildTimePlugin() {
        this.hooks.done.tapAsync('end', function(stats, callback) {
          if (!stats.compilation.errors.length) {
            const secs = (stats.endTime - stats.startTime) / 1000
            colorconsole.info(`Build Time Cost: ${secs}s`)
          }
          callback()
        })
      },
      new ManifestWatchPlugin({
        appRoot: cwd,
        root: SRC_DIR
      })
    ],
    node: false,
    resolve: {
      modules: ['node_modules'],
      extensions: ['.webpack.js', '.web.js', '.js', '.json'].concat(name.extList)
    },
    stats: {
      builtAt: false,
      entrypoints: false,
      children: false,
      chunks: false,
      chunkModules: false,
      chunkOrigins: false,
      modules: false,
      version: false,
      assets: false
    },
    optimization: {}
  }

  // 设置抽取公共js
  if (compileOptionsObject.splitChunksMode === compileOptionsMeta.splitChunksModeEnum.SMART) {
    colorconsole.warn(
      `启用splitChunksMode:SMART模式, 请确保平台版本 >= ${SPLIT_CHUNKS_SUPPORT_VERSION_FROM}`
    )
    // 当前仅smart模式才启用
    webpackConf.optimization.splitChunks = {
      minSize: 1,
      maxSize: 0,
      cacheGroups: {
        default: false,
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          chunks: 'all',
          minChunks: 2,
          name(module) {
            // 处理node_modules的chunk位置为node_modules下的路径,通过name来控制,如node_modules/vue/dist/vue.runtime.esm;
            const index = module.resource.indexOf('node_modules')
            const chunkPath = module.resource
              .slice(index)
              .replace(/(.+)\.\w\??(.+)?/, ($0, $1) => $1)
            // 兼容windows上的路径
            return chunkPath.split(path.sep).join('/')
          },
          priority: 2,
          reuseExistingChunk: true,
          enforce: true
        },
        chunks: {
          test(module) {
            // 过滤掉自定义module，比如抽取css生成*.css.json使用的CssModule
            if (module.constructor.name !== 'NormalModule') {
              return false
            }
            return true
          },
          chunks: 'all',
          minChunks: 2,
          name(module) {
            // 处理正常chunk的位置为相对src下的路径，通过name来控制,如Common/a;
            const sourcePath = path.join(globalConfig.projectPath, globalConfig.sourceRoot)
            const chunkPath = module.resource
              .slice(sourcePath.length + 1)
              .replace(/(.+)\.\w\??(.+)?/, ($0, $1) => $1)
            // 兼容windows上的路径
            return chunkPath.split(path.sep).join('/')
          },
          priority: 1,
          reuseExistingChunk: true,
          enforce: true
        }
      }
    }
  }

  // 加载配置
  loadWebpackConfList()

  // 设置 sourcemap 类型
  webpackConf.devtool = getDevtool(webpackConf.mode, compileOptionsObject.devtool)

  /**
   * 尝试加载每个模块的webpack配置
   */
  function loadWebpackConfList() {
    const moduleList = [
      {
        name: 'packager',
        path: pathMap['packager']
      }
    ]

    const dslName = getProjectDslName(cwd)

    moduleList.push({
      name: `${dslName}-post`,
      path: pathMap[dslName]
    })

    const { package: appPackageName, icon: appIcon, versionCode, subpackages, workers } = manifest
    for (let i = 0, len = moduleList.length; i < len; i++) {
      const fileConf = moduleList[i].path
      if (fs.existsSync(fileConf)) {
        try {
          const moduleWebpackConf = require(fileConf)
          if (moduleWebpackConf.postHook) {
            moduleWebpackConf.postHook(
              webpackConf,
              {
                appPackageName,
                appIcon,
                versionCode,
                nodeConf: env,
                pathDist: DIST_DIR,
                pathSrc: SRC_DIR,
                subpackages,
                pathBuild: BUILD_DIR,
                pathSignFolder: SIGN_FOLDER,
                workers,
                cwd
              },
              quickappConfig
            )
          }
        } catch (err) {
          console.error(`加载 webpack 配置文件[${fileConf}]出错：${err.message}`, err)
        }
      }
    }

    // 增加项目目录的postHook机制
    if (quickappConfig && quickappConfig.postHook) {
      quickappConfig.postHook(webpackConf, compileOptionsObject)
    }
  }

  /**
   * TODO 应该移动到其他文件，而不是这个文件里
   * 验证项目的应用全局配置
   * @param {Manifest} manifest - manifest 对象
   */
  function validateManifest(manifest, options) {
    const { subpackages } = manifest
    // 验证分包规则
    if (!options.disableSubpackages && subpackages && subpackages.length > 0) {
      validateManifestSubpackages(subpackages)
    }
  }

  /**
   * 检查subpackages字段配置。
   * 除subpackages字段指定的文件是打进非主包外，剩余文件都打进主包
   * 主包与是独立包的非主包，都需要manifest文件
   * @param {object[]} subpackages 分包列表: [{ name, resource, standalone, icon }]
   * @param {string} subpackages[].name 分包名字，必填，不能重复，且不能是"base"（这是主包保留名），只能是 数字字母_ 组成
   * @param {string} subpackages[].resource 分包资源路径，必须为src下文件目录，不能重复，分包间不能有包含关系，只能是 数字字母_ 开头，数字字母_-/ 组成
   * @param {boolean} subpackages[].standalone 是否独立包标识，是独立包则需要manifest文件，缺省为false；
   * @param {boolean} subpackages[].icon 分包icon，是独立包则需要icon，缺省则为应用的icon；
   */
  function validateManifestSubpackages(subpackages) {
    // 分包名的校验规则
    const nameReg = /^\w+$/
    // 资源名的校验规则
    const resourceReg = /^\w[\w-/]*$/
    // 用以检测分包名是否重复
    const nameList = []
    // 用以检测分包资源路径是否重复
    const resList = []
    // i18n文件目录地址，不能作为分包
    const i18nPath = path.join(SRC_DIR, 'i18n')
    let name = ''
    let resource = ''

    // 资源路径的具体文件路径
    let resPath = ''
    let index = 0

    /**
     * 检查当前资源路径与已校验过的资源路径是否有包含关系。
     *
     * @param {string} resource - 当前要校验的资源
     * @param {number} index - 当前要校验资源的序号
     * @return {boolean} true/false - 存在/不存在
     */
    function checkPathInclusion(resource, currentIndex) {
      for (let i = 0, l = resList.length; i < l; i++) {
        const _res = resList[i]
        if (resource.startsWith(_res) || _res.startsWith(resource)) {
          colorconsole.throw(
            `第${currentIndex}分包的资源'${resource}'与第${i +
              1}分包的资源'${_res}'有包含关系，请修改`
          )
          return true
        }
      }
      return false
    }

    subpackages.forEach((subpkg, i) => {
      name = subpkg.name
      resource = subpkg.resource
      resPath = resource && path.join(SRC_DIR, resource)
      index = i + 1

      if (!name) {
        colorconsole.throw(`第${index}分包的名字不能为空，请添加`)
      } else if (!nameReg.test(name)) {
        colorconsole.throw(`第${index}分包的名字'${name}'不合法，只能是数字字母下划线组成，请修改`)
      } else if (name === MAIN_PKG_NAME) {
        colorconsole.throw(`第${index}分包的名字'${name}'是主包保留名，请修改`)
      } else if (nameList.indexOf(name) > -1) {
        colorconsole.throw(`第${index}分包的名字'${name}'已存在，请修改`)
      } else {
        nameList.push(name)
      }

      if (!resource) {
        colorconsole.throw(`第${index}分包的资源名不能为空，请添加`)
      } else if (!resourceReg.test(resource)) {
        colorconsole.throw(
          `第${index}分包的资源名'${resource}'不合法，只能是 数字字母_ 开头，数字字母_-/ 组成，请修改`
        )
      } else if (resList.indexOf(resource) > -1) {
        colorconsole.throw(`第${index}分包的资源'${resource}'已被使用，请修改`)
      } else if (!fs.existsSync(resPath)) {
        colorconsole.throw(`第${index}分包的资源'${resource}'，文件目录'${resPath}'不存在，请修改`)
      } else if (resPath === i18nPath) {
        colorconsole.throw(
          `第${index}分包的资源'${resource}'，文件目录'${resPath}'，i18n文件目录不能作为分包，请修改`
        )
      } else if (!checkPathInclusion(resource, index)) {
        resList.push(resource)
      }

      if (subpkg.standalone && subpkg.icon && !fs.existsSync(path.join(SRC_DIR, subpkg.icon))) {
        colorconsole.throw(`第${index}分包配置的icon不存在，请修改`)
      }
    })
    colorconsole.warn(
      `项目已配置分包，若想使用分包功能，请确保平台版本 >= ${RPKS_SUPPORT_VERSION_FROM}`
    )
  }
  return webpackConf
}
